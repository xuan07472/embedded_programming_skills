# C语言框架讲解   

---

(送书)整体介绍C语言，一期视频完整介绍C语言有用知识  

[b站配置视频地址](https://space.bilibili.com/106424039)  

|作者|将狼才鲸|
|---|---|
|日期|2021-07-17|

_注：gitee暂不支持markdown mermaid流程图显示，需要下载Typora等软件打开本.md文件才能查看流程图和框图_  
<br>

## 一、引出C语言  

<center>图1 主观理解</center>  

```mermaid
graph LR
subgraph 真实
A[世界]
A1[输入 输出]
end
subgraph 镜像
B[大脑]
C[C语言程序]
end
A --动态镜像--> B
A1 --静态处理--- C
```
<center>图2 C语言关联事务</center>  

```mermaid
graph TB
subgraph 知识图谱
D[抽象]
E[逻辑学]
F[布尔运算]
G[控制论]
H[图灵机]
I[冯洛伊曼结构]
J[通信]
J1[数值计算]
K[模数转换]
L[数模转换]
end
D --> M[C语言]
E --> M
F --> M
G --> M
H --> M
I --> M
J --> M
J1 --> M
K --> M
L --> M
subgraph 依赖
    N[硬件]
    subgraph 硬件
    O[运算CPU]
    P((传感器))
    Q((执行器))
	R[存储RAM ROM]
	S[传输 总线]
    end
    S1[软件]
    subgraph 软件
    T[BOOT]
    T1[底层软件 硬件基本初始化 或操作系统平台]
    U[编辑器]
    V[编译器]
    W[编译原理]
    X[链接器]
    Y[标准输出 驱动]
    Z[标准库]
    end
end
N --> O
N --> P
N --> Q
O -.- R
P -.- S
M --> N
M --> S1
T --> T1
U -.- X
V -.- Y
W -.- Z
S1 --> T
S1 --> U
S1 --> V
S1 --> W
```

我假设人认知世界是将世界在大脑中动态的做了一个**镜像**，那么C语言程序就是将世界的信息做一个静态的处理，或者将处理的信息送出外界。  
**图灵机**，用机器模拟数学计算并且证明可行：动态数据 + 固定程序 + 状态和数据存储 + 顺序指针和跳转执行。  
**冯洛伊曼结构**： 指令和数据合并在一起（因此指针能调用函数，也能调用数据，也能调用寄存器，代码段和数据段本质上是一样的结构）。  

## 二、C语言功能  

<center>图3 C语言框架——数据布局</center>  

```mermaid
graph TB
subgraph 实际地址布局
	subgraph 关心
        subgraph .text
        A[代码段.text]
        end
        subgraph .data
        B[数据段.data]
        B1[已初始化全局变量]
        B2[已初始化局部静态变量]
        B==>B1---B2
        end
        subgraph .bss
        C[.bss段]
        C1[未初始化全局变量]
        C2[未初始化局部静态变量]
        C==>C1---C2
        end
        subgraph .rodata
        D[常量.rodata]
        D1[字符串常量]
        D2[const常量]
        D3[#define常量]
        D==>D1---D2
        D==>D3
        end
    end
    subgraph 不关心
    ELF头 -.- 段头表 -.- .init_main之前初始化代码 -.- F1[.symtab]
    E[.debug] -.- .line -.- 节头表_描述目标字节 -.- F2[.strtab变量名函数名]
    .rel.text重定位表 -.- heap堆malloc分配 -.- F3[stack栈函数内局部变量]
    	subgraph 中间文件和库文件
        .a -.- F4[.o]
        .so
        end
    end
A-.-E
B2-.-E
C2-.-E
D2-.-E
end
subgraph C语言
G[C语言]
end
F1==>G
F2==>G
F3==>G
F4==>G
```

_注：不同编译器生成的地址布局名称不一样，这里以gcc举例，其它编译器大同小异_  

<br>

<center>图4 C语言框架——功能</center>  

```mermaid
graph LR
subgraph C语言
A[C语言]
end
B[跳转]
B1[函数调用]
B2[内存地址转函数指针并调用]
B3[if else for while switch goto break contine return]
B4[硬件上的总线传输]
B-->B1
B-->B2
B-->B3
B-->B4
C[运算]
C1[算术运算]
C2[逻辑运算]
C3[位运算]
C4[左移右移运算]
C5[关系运算]
C-->C1
C-->C2
C-->C3
C-->C4
C-->C5
```

if, else, else if, for, while, while do, do while, swith case, break, continue，goto, ,逗号运算符, ?:运算符本质上都是内存地址的跳转，实际上只用if和goto语句就能实现以上所有的功能；  
同理，只用汇编的JMP LJMP AJMP SJMP（51汇编）或者B BL BLX BX（ARM）指令也能实现C语言的上述功能。  

|关键字||||||||
|---|---|---|---|---|---|---|---|
|数据|char| int| long |float |double |short |void |
||signed |unsigned |volatile |enum |struct |union |const |
||auto |extern  |static |register ||||
|跳转|for |if| else| while| do| switch| case| default| break|
||continue| goto | return||||||||||
|函数| sizeof |typedef |inline|||||
|不关心 |restrict| _Bool |_Complex| _Imaginary| _Alignas| _Alignof| _Atomic|
||_Static_assert| _Noreturn| _Thread_local |_Generic||||

<center>表1 C语言关键字</center>  

|编译器||||||||
|---|---|---|---|---|---|---|---|
| 常量后缀 | u/U  | l/L  | f/F  | ul/UL | lu/LU | ll/LL | llu/LLU |
| 常量前缀 | 0    | 0x   | 0b   |L宽字节中文字符串||||
|字节对齐|#pragma pack (n)| #pragma pack () |__attribute__ ((aligned (n))) |__attribute__ ((packed))|多用于硬件寄存器结构体|和通讯数据结构体正确操作数据|因为一般OS都会默认四字节或两字节补齐|
|字符串宏|\_\_DATE\_\_| \_\_TIME\_\_ |\_\_func\_\_ |\_\_LINE\_\_|\_\_FILE\_\_|\_\_cplusplus|\_\_FUNCTION\_\_|

<center>表2 编译器关键字</center>

另：字节对齐对结构体和硬件寄存器尤其重要  

另：\_\_DATE\_\_  \_\_TIME\_\_  \_\_func\_\_  \_\_LINE\_\_  \_\_FILE\_\_  \_\_cplusplus  \_\_FUNCTION\_\_在debug调试输出log时非常有用，能准确知道程序在哪个文件的哪个函数的哪一行出错  
<br>

|运算符及优先级||
|---|---|
|范围限定及单目|()括号和强制转换 [] -> . !非 ~反 ++ -- +正 -负 *取值 &取址|
|算术运算|\*乘 /除 %余 +加 \-减 |
|整体运算|<<左移 >>右移|
|判断运算 |<小于 >大于 <=小于等于 >=大于等于 ==等于 !=不等于|
|位运算 |&按位与 ^按位异或 \|按位或|
|逻辑运算 |&&与 或\|\||
|条件运算| ?:问号冒号运算符 ,逗号运算符 （这两个都经常用，可以缩小代码量，让代码更清晰）|
|赋值| = += \-+ *= /+ %= &= \|= \<\<= \>\>= ^= |

<center>表3 运算符和优先级</center>  

快捷优先级记忆：算数整体判断位逻辑，操作符多的时候尽量用括号括起来  

另：左移右移也是乘2和除2，遇到乘2除2时应该用左移右移代替，提高运算速度  

另：运算符生效顺序有些是由右往左，有些是由左往右，需要记忆  
[运算符优先级](https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7)  

## 三、C语言与高级语言的异同  

- 当前计算机是冯洛伊曼结构或其改进结构，即指令和数据合并在一起，所以指针能调用函数也能调用数据也能调用寄存器；因为**指令**地址、**数据**地址、**寄存器**地址**本质上是一样**的东西，所以理论上通过指针可以跳转到代码中的任何位置，访问任何数据；同样的也能修改任何全局变量，修改任何内存，控制任何硬件。  
- 所以，如果不想清楚后再写C语言程序的话，特别是还使用指针和内存分配动态分配的情况，经常会遇到运行时程序崩溃的情况。  
- C语言可以通过结构体、指针（以及指针组成的链表）、指针函数，可以实现高级语言类Class的功能，大型的程序如Linux kernel、ffmpeg、QEMU等都整体使用这种特性。
- 语言将一个模块所有全局变量都挪到结构体内，通过结构体和函数指针调用其它模块，通过void \*指针转换其它结构体数据，可以实现继承、派生等功能。  
- C语言可以用goto实现异常处理和资源销毁。  
<br>
- 高级语言自带类Class，一个类就类似于C语言中一个模块，而且一般都是类型安全、内存安全、权限安全的，有异常处理手段。  
<br>
- 虽然计算机原理是由控制器、运算器、存储器、输入设备、输出设备组成的，但是其实以上任何一项内容里也可以继续包含子系统，比如键盘和鼠标里有51芯片，硬盘里有主控芯片，显示屏里也有显示芯片，有显卡，CPU有一二三级缓存、有总线。  

## 四、C语言模块  

### 1. 标准库  
- 编译器提供代码事先初始化一部分硬件，如CPU、内存、分频倍频、串口的对接，这部分代码放在.init段（上电时从ROM搬运到RAM），并且在main()函数之前执行；或者启动操作系统的一个窗口（控制台），重定向标准输入输出流到此控制台。  
- 编译器还提供了一些常用的函数，即C语言标准程序库，使用到了哪些函数，生成程序时就把此部分机器码放到可执行文件中（链接）。  
<br>
- 常用的头文件（模块）如stdio.h、string.h、stdlib.h。  
- 常用的函数如printf()、scanf()。  
<br>
C语言标准由iso官网下载，而且下载要钱，当前版本2018  
[ISO/IEC 9899:2018 Information technology — Programming languages — C](https://www.iso.org/standard/74528.html)  
下一个版本的C2x标准，预计将于2022年12月1日完成  
C标准库glibc [The GNU C Library (glibc) 源码](http://www.gnu.org/software/libc/)  
[The GNU C Library 使用手册](https://www.gnu.org/software/libc/manual/html_mono/libc.html)  
不同编译器的标准库头文件数目不一样
[C语言标准库 中文解析](http://c.biancheng.net/cpp/u/biaozhunku/)  
嵌入式编译器对glibc中的内容可能并不完全实现，只实现常用的那部分，如stdio.h string.h stdlib.h ，像time.h可能就用不了，因为有些嵌入式设备都没有RTC，或者除了tick时钟滴答（主频的循环计数）不需要时分秒，而且不同月份天数、闰年闰月的计算也会增大可执行文件的大小。  

### 2. 输入、输出、输出级别、日志  
- 输入输出的常用接口是printf()、scanf()，一般是默认重定向到console，如串口或者控制台，但是也可以在编译器中将输入输出重定向到其它位置，比如debug时的IDE窗口、文件、其它串口等。  
- 输入输出支持多个数据与字符串之间的转换（控制符）和转移字符，如：  

|%s| %c| %d| %f| %ld长整型| %lld| %u无符号| %.md限制小数点位数的浮点数 |
|---|---|---|---|---|---|---|---|
|%x %X十六进制（小写 大写）| %08x定长八个字符十六进制|%#x %#X带0x开头|\t tab制表|\r换行|\r\n回车换行|其它\a \b \f \v \\' \\" \\\\||

<center>表4 控制符和转义字符</center>  

- 对printf进行封装形成带级别的输出函数，如pr_info() pr_debug() pr_warnning() pr_detail()，在系统设置了可输出的宏级别后，只允许达到级别的输出生效；也可以使用pr(INFO, "out string.\n");类似的形式。  
- 在printf()输出信息时可以携带编译器提供的字符串，如文件名、函数名、文件行数、编译时的时间（这些信息可以在自己封装的函数如pr_info()调用时自动添加上，不用每条语句都手动写），如：  

```c
#include <stdio.h>

int main()
{
	#define LINEFEED "\n" // "\r\n"

	printf("[INFO] " "build time:%s %s" "%s", __DATE__, __TIME__, LINEFEED);
	printf("[ERROR]" "[locate:%s %s() line:%d] " "%s" "%s",
           __FILE__, __func__, __LINE__, "process error!", LINEFEED);

	return 0;
}
// 输出信息：
// [INFO] build time:Jul 17 2021 16:20:42
// [ERROR][locate:main.c main() line:8] process error!

```

这时候如果程序出错，调试时不需要使用仿真器（调试器），直接看输出log信息就能看到程序在哪里出错。  

[高级输出级别控制 示例代码](https://gitee.com/langcai1943/embedded_programming_skills/blob/develop/1_src/02-print_control/print_ctrl.h)  

#### 2.1 字符串、编码格式  

- 计算机除了计算，主要就是处理信息，那么对信息的定义就尤其重要，数据的类型如整型、浮点型等后面再说，本章节只说文件（字符串）编码格式，格式有：  

| ASCII                            | Unicode                     | GB2312                      | UTF-8                |
| -------------------------------- | --------------------------- | --------------------------- | -------------------- |
| 128个有效字符不含中文、C语言默认 | QT、VisualStudo、JAVA等默认 | 国标、节省空间、Windows默认 | Linux默认、iOS默认   |
|                                  | \r                          | \r\n                        | \n                   |
|                                  | 苹果iOS换行符               | Windows换行符               | Linux/嵌入式换换行符 |

<center>表5 文件格式和换行格式</center>  

- 操作系统提供文件系统，如果裸机就需要拷贝开源文件系统模块到自己的源码工程中，还需要提供Flash等存储器驱动。  
- 相关的内容还有国际化和本地化。  
- 字符串中使用中文需要使用宽字符，wchar_t str = L"中文字符串"; 是将字符串强制转换成固定两字节的Unicode格式，如下：  

```c
#include <wchar.h>
#include <wctype.h>
wchar_t str = L"中文字符串"; // 具体使用的wchar_t等关键字依赖于编译器或操作系统
```

- 对中文的支持与各编译器相关，请与当前使用的操作系统和编译器为准。  

- 当你需要对通讯链路上的数据进行操作，解析JSON、XML、ini等配置文件时，就不得不进行字符串的复杂操作，你需要掌握字符串查找、字符串拼接、字符串分割、字符串转整型、字符串转浮点型等技能。  
- 你可以直接用指针操作字符串，类似于这样：  

```c
#include <stdio.h>

#define MAX_LEN 64

char *in_data = "head,cmd:01,data:Open_machine,end"; // 控制字符串，以,逗号和冒号进行分割
//char *in_data[] = {0xAA, 0xBB, 0x03, 0x01, 0x55, 0x55, 0xCC, 0xDD}; // 包头AABB，包长03，命令码01，数据5555，包尾CCDD
char tmp[MAX_LEN];
char tmp2[MAX_LEN];

/* 找到控制字符串data下的数据Open machine */
int main()
{
	int i;
	char *indata = in_data;
	char *item;
	char *cmd;

	while (*indata != '\0') { // 如果文件未达到结尾则一直循环
		item = tmp;
		while (*indata != ',' && *indata != '\0') { // 分割控制字符串
			*item = *indata;
			item++;
			indata++;
		}
		*item = '\0'; // 手动设置字符串结尾

		item = tmp; // 将指针重新定位到字符串开始位置
		cmd = tmp2;
		while (*item != ':' && *item != '\0') {
			*cmd = *item;
			cmd++;
			item++;
		}
		*cmd = '\0';

		cmd = tmp2;
		printf("cmd-%s-\n", cmd);
		if (cmd == "data") { // 找到命令码
			printf("找到了data命令\n");
			item++; // 跳过:冒号
			while (*item != '\0') {
				*cmd = *item; // 重新利用cmd缓存，存储命令数据
				cmd++;
				item++;
			}
			cmd = tmp2;
			printf("找到了Open_machine数据\n");
			printf("=%s=\n", cmd);
		}
		indata++;
	}
}
// 由此可见，由自己实现字符串的操作比较复杂，而且重用性不好，所以推荐掌握好strstr, strncpy, strcat, strcmp, strlen等系统函数
```

- 字符串和整型、浮点型等相互转换的系统函数为**atoi()，itoa()， atof()， ftoa()，**如果是嵌入式编译器对其中有些函数不支持，则上网抄该函数实现的源码。  
- 其它很有用的操作：vsprintf()用printf参数的方式把字符串输出到开辟的内存或数组中，vsnprintf()，vprintf()

#### 2.2 文件操作  

- 文件操作涉及到文件系统和对Flash、硬盘等ROM的驱动管理。  
- 文件系统，表格如下：  

|Windows|Linux|iOS|嵌入式|
|---|---|---|---|
|FAT32 FAT16 NTFS|EXT EXT2 EXT3 EXT4 XFS|HFS UFS APFS|Ramfs JFFS2 VAFFS ROMFS Ramdisk|

<center>表6 文件系统格式</center>  

- Ramfs用户空间是映射到内存的，用户修改了文件之后，断电重启文件又会恢复。因为嵌入式程序的权限很大，这样改错了文件也不至于让设备成为板砖。  
- Windows、Linux、iOS的文件系统更适合硬盘等设备，也可以用在嵌入式中，让嵌入式设备支持；但嵌入式设备的文件系统更适合Flash等ROM，性能、空间消耗更小。  
- 很多嵌入式设备尤其是单片机，根本就没有文件系统，对数据的读取都是直接读Flash。  

- 文件操作，如二进制文件，文本文件，文件操作：打开、定位、修改、替换、覆盖、新建、保存等。  
- C语言直接使用<stdio.h>中的文件操作函数即可，如FILE *fopen(char *filename, char *mode);  
|结构体和宏|size_t|FILE文件指针|EOF文件结尾|SEEK_CUR当前位置|SEEK_END文件末尾|SEEK_SET文件开头|……|
|---|---|---|---|---|---|---|---|
|文件操作|fopen|fwrite|fread|rewind跳到文件开头|ftell获取文件长度|fseek跳转到指定位置|fclose|
||fflush保存文件前先把已写入但是还在缓存中的数据同步到存储介质中去|……||||||
|open时标志|r只读|r+读写|rb+读写二进制|w只写|w+新建且可读写|wb|rw等|

<center>表7 文件操作</center>  

- 具体的文件操作还是要自己写几个demo，实际跑一下才能弄清楚。  
- 非常有用的文件格式有JSON、XML、INI等文件，不管是存储数据，获取配置都很有用，需要掌握。这些文件都涉及到字符串**键值对**，和键值对的嵌套，对这些文件的增删改查操作用到了结构体+指针链表+递归，但是有解析这些文件的开源项目，可以直接抄到自己的代码工程中。

### 3. 书写规范  

命名、空格、括号位置、注释，详见：  
[C语言编码规范和注释规范详解](https://gitee.com/langcai1943/embedded_programming_skills/blob/develop/1_src/01-c_comments/main.c)  
错误码、错误提示字符串，详见<errno.h>（如果是嵌入式编译器需要自行实现），详见：  
[C语言错误码](https://gitee.com/langcai1943/embedded_programming_skills/blob/develop/1_src/07-error_no/errno.h)  

### 4. 多线程、同步竞争、操作系统  

- 线程的操作和同步竞争机制，不同的操作系统使用方法不一样，但是基本概念一样，这里以Linux举例。  

```c
#include <pthread.h> // 线程、互斥、条件变量
#include <semaphore.h> // 信号量

```

|pthread_create()创建|pthread_exit()终止|pthread_join()等待|pthread_cancel()|pthread_kill()|
|---|---|---|---|---|
|pthread_mutex_t互斥锁|pthread_cond_t条件变量||||

- 其它：死锁、原子操作、PV操作、信号量、自旋锁、邮箱、管道  
- 因为线程和同步竞争涉及到操作系统原理的背景知识，需要知道编码时对竞争现象的避免，优先级反转，流水线等基础知识，这里不过深入介绍，需要自行多写demo进行练习。  

### 5. 运算、算法  

- 数学库<math.h>  
- 数学库运算函数：三角函数、双曲函数、指数函数、对数函数、幂函数、就近舍入函数、绝对值函数、取余函数、误差函数、伽马函数、最大值函数、最小值函数、正差函数、qsort函数 。  
- 数学计算：矩阵，快速傅里叶变换，复数，多用于算法、通讯计算。  
- malloc/realloc/free动态存储分配、指针、利用内存进行多中算法计算。  
- 数据结构：数组、多维数组、链表、单向链表、双向链表、表、图。  
- 链表可以用来实现**循环缓存**、console菜单、UI菜单、JSON文件解析、XML文件解析、实现面向对象。对写应用来说链表非常重要。  
- 链表的创建、链表插入结点、搜索链表、从链表中删除结点、有序链表。  
- 指针的嵌套：指向指针的指针、指向函数的指针、受限指针、弹性数组成员。  
- 指针再配合extern声明打破层级结构，理论上可以形成无限复杂的结构，因为硬件上的函数调用就是跳到指定位置，学过汇编就知道，理论上跳到哪里都可以，所以可以跳到任何地方，又从任何地方跳回来。  
<br>
- 有符号字符、无符号字符 、常规算术转换、赋值过程中的转换、隐式转换、强制类型转换。类型转换也是导致C语言程序经常出错的原因。  
- stdint.h整数类型，inttypes.h数值兼容，complex.h复数算术运算、gmath.h、fenv.h。  

### 6. 函数、模块、结构体  

#### 6.1 函数可变参数  

- C 语言中最常用的可变参数函数例子是 printf()、scanf()、Linux应用程序的调用（如ls -l命令），用处还是很广，实现的原理是利用函数参数是存放在栈中，是连续存放的，利用地址指针的连续性和参数个数获取所有参数。main()函数也是默认携带int argc, void *argv[]参数的。
- 实现这种特性的原理在其它地方也很有用。

- 两种调用形式：
int main(int argc, char *argv[]) {}
void func(int argc, ...) {}

```c
/* 简单使用 */
#include <stdio.h>

int main(int argc, char *argv[])
{
	printf("参数个数：%d\n", argc);
    printf("程序路径和程序名：%s\n", argv[0]);

    /* 读取参数 */
    for (int i = 0; i < argc; i++) {
    	printf("参数%d：%s\n", i, argv[i]);
    }

    return 0;
}
/* 运行结果
$ ./demo.exe 中国 China china bilibili
参数个数：5
程序路径和程序名：C:\Users\jim\Desktop\demo.exe
参数0：C:\Users\jim\Desktop\demo.exe
参数1：?й?
参数2：China
参数3：china
参数4：bilibili
*/
```

```c
/* 高级使用 */
#include <stdio.h>
#include <stdarg.h>

/* 无法直接确定可变参数的个数，可以用一个int参数或者char *format参数传入值然后读出或者解析出参数个数，并且每个参数的类型也要自行约定好 */
void func(int argc, float param2, char * param3, ...)
{
	va_list arg;
	va_start(arg, param3);

	printf("固定参数1（约定为可变参数的个数）：%d\n", argc);
	printf("固定参数2：%f\n", param2);
	printf("固定参数3：%s\n", param3);

	int param4 = va_arg(arg, int); // 可变参数的前一个参数，指示可变参数开始的位置
	printf("可变参数4：%d\n", param4);
	double param5 = va_arg(arg, double); // double为约定好的类型
	printf("可变参数5：%f\n", param5);
	char *param6 = va_arg(arg, char *);
	printf("可变参数6：%s\n", param6);

	va_end(arg);
}
 
int main(int argc, char **argv)
{
	func(3, 2.2, "CCC", 4, 5.5, "ff");

	return 0;
}
/*
执行结果：
$ ./demo.exe
固定参数1（约定为可变参数的个数）：3
固定参数2：2.200000
固定参数3：CCC
可变参数4：4
可变参数5：5.500000
可变参数6：ff
*/
```

- 起始可变变量的实现，是利用了连续的内存存储，指针、sizeof()、 offsetof()、 typeof()这些系统函数的特性实现的。  
- 利用相同的特性还可以实现利用结构体实现Class类，以及类的继承，还有通讯中数据的分层解析和传递等功能。  

stdarg.h 可变参数 调用带有可变参数列表的函数 v…printf函数 v…scanf函数 stdlib.h 通用的实用工具 数值转换函数 伪随机序列生成函数 与环境的通信 搜索和排序实用工具 整数算术运算函数 地址对齐的内存分配 time.h 日期和时间 时间处理函数 时间转换函数
嵌 
函数定义 函数调用 函数声明 实际参数 实际参数的转换 数组型实际参数 变长数组形式参数 存储的堆栈 编译器 代码段 程序段
在数组参数声明中使用static inline #define # ## 
return语句 程序终止 递归 嵌入式要慎重使用，很容易堆栈溢出程序崩溃，嵌入式最好把内存的使用

链接期间的错误 重新构建程序 在程序外定义宏 在工程中定义宏 定义pc编译器 定义交叉编译器
结构、联合和枚举 结构变量 结构变量的声明 结构变量的初始化 指示器 对结构的操作 结构类型 结构标记的声明 结构类型的定义 结构作为参数和返回值 复合字面量 匿名结构 嵌套的数组和结构
嵌套的结构 结构数组 结构数组的初始化 联合 硬件寄存器
用联合来节省空间 同时操作一个硬件寄存器和硬件寄存器中一个位 或者操作整个标志和标志中一个位 用联合来构造混合的数据结构 为联合添加“标记字段” 匿名联合
枚举 枚举标记和类型名 枚举作为整数 用枚举声明“标记字段”

初始化器 内联函数 内联定义 对内联函数的限制 在GCC中使用内联函数　372
函数指定符_Noreturn和头stdnoreturn.h静态断言
程序设计 模块 内聚性与耦合性 mvc
模块的类型 信息隐藏 抽象数据类型 封装 不完整类型 栈抽象数据类型 为栈抽象数据类型定义接口　 用定长数组实现栈抽象数据类型 改变栈抽象数据类型中数据项的类型 用动态数组实现栈抽象数据类型 用链表实现栈抽象数据类型 抽象数据类型的设计问题 命名惯例 小写下划线命名 驼峰命令 混合命名 默认名称 缩写名称 2 4
错误处理 通用抽象数据类型  新语言中的抽象数据类型

一种从元素地址倒推数据结构首地址的方法: offsetof typeof

使用sizeof等从结构体子项目指针地址获取到上级元素地址或者主结构体地址  
宏定义函数
内联函数，没有自己的栈，节省内存空间


#### 6.1 宏定义、区块控制、宏定义函数



[#define宏定义函数示例代码](https://gitee.com/langcai1943/embedded_programming_skills/blob/develop/1_src/02-print_control/print_ctrl.h)  

工作原理 预处理指令 宏定义 #define宏定义函数 C99 C11 C标准官网。。。。。。
简单的宏 带参数的宏 #运算符 ##运算符 宏的通用属性 \反斜杠 变量都用()圆括号包住，否则有bug
宏定义中的圆括号 创建较长的宏 预定义宏 C99中新增的预定义宏 空的宏参数
参数个数可变的宏 函数参数的可变参数，利用了堆栈和指针的原理来实现的 argc argv
__func__标识符 条件编译 #error多个平台多个配置时防止应用出错 
#if指令和#endif指令 defined运算符 #ifdef指令和#ifndef指令 #elif指令和#else指令
当成脚本来使用 __开头和__结尾的命名方法和编译器有关系
使用条件编译 其他指令 #error指令 #line指令 #pragma指令 _Pragma运算符
编写大型程序 源文件 头文件 #include指令 模块概念 类概念 分层概念 尽量单向调用概念

共享宏定义和类型定义 共享函数原型  共享变量声明 嵌套包含 保护头文件 头文件中的#error指令　#ifndef #define #endif
把程序划分成多个文件 构建多文件程序 makefile keil visualStudio qt qmake cmake automake

#### 6.2 指针  

静态划分好
泛型选择 程序结构 局部变量 静态局部变量 形式参数 外部变量 用外部变量实现栈 程序块 作用域
指针 指针变量 取地址运算符和间接寻址运算符 按结构体获取首地址 取地址运算符 间接寻址运算符 指针赋值 指针作为参数 指针作为返回值 类似于微积分的微分、积分

内存地址，寄存器地址，带宽，位宽，信息论，镜像，代指
指针和数组 指针的算术运算 指针加上整数 指针减去整数 两个指针相减 指针比较 指向复合字面量的指针 指针用于数组处理 用数组名作为指针 数组型实际参数 指针作为数组名 指针和多维数组 处理多维数组的元素 处理多维数组的行 处理多维数组的列 用多维数组名作为指针 C99中的指针和变长数组 


### 7. 网络、通信  
socket tcp/ip osi7层分层

常用：网络、wifi、usb、2g3g4g5g、蓝牙、
嵌入式：串口、i2c spi can zigbee i2s ......

### 8. 硬件操作  

大量数据节省存储空间 硬件操作必须
底层程序设计 位运算符 移位运算符 按位取反运算符、按位与运算符、按位异或运算符和按位或运算符 用位运算符访问位 用位运算符访问位域 结构中的位域
其他底层技术 定义依赖机器的类型 用联合来提供数据的多个视角 将指针作为地址使用 volatile类型限定符 对象的对齐 align
对齐运算符_Alignof 对齐指定符_Alignas和头stdalign.h
标准库

声明的语法 存储类型 变量的性质 auto存储类型 static存储类型 extern存储类型 register存储类型　 类型限定符 声明符 解释复杂声明 使用类型定义来简化声明

---



